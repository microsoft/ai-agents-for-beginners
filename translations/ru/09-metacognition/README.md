<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8cbf460468c802c7994aa62e0e0779c9",
  "translation_date": "2025-07-11T14:29:50+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "ru"
}
-->
[![Multi-Agent Design](../../../09-metacognition/images/lesson-9-thumbnail.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(Нажмите на изображение выше, чтобы посмотреть видео этого урока)_
# Метапознание в AI-агентах

## Введение

Добро пожаловать на урок о метапознании в AI-агентах! Эта глава предназначена для начинающих, которые интересуются тем, как AI-агенты могут размышлять о своих собственных мыслительных процессах. К концу этого урока вы поймете ключевые концепции и получите практические примеры применения метапознания в проектировании AI-агентов.

## Цели обучения

После завершения этого урока вы сможете:

1. Понять последствия циклов рассуждений в определениях агентов.
2. Использовать методы планирования и оценки для помощи агентам в самокоррекции.
3. Создавать собственных агентов, способных манипулировать кодом для выполнения задач.

## Введение в метапознание

Метапознание относится к высшим когнитивным процессам, которые включают размышления о собственном мышлении. Для AI-агентов это означает способность оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Метапознание, или "мышление о мышлении", является важной концепцией в развитии агентных AI-систем. Оно включает в себя осознание AI-системами своих внутренних процессов и способность контролировать, регулировать и адаптировать свое поведение соответственно. Подобно тому, как мы оцениваем ситуацию или анализируем проблему. Это самосознание может помочь AI-системам принимать более обоснованные решения, выявлять ошибки и улучшать свою производительность со временем, что снова возвращает нас к тесту Тьюринга и дебатам о том, захватит ли AI мир.

В контексте агентных AI-систем метапознание может помочь решить несколько задач, таких как:
- Прозрачность: Обеспечение способности AI-систем объяснять свои рассуждения и решения.
- Рассуждение: Улучшение способности AI-систем синтезировать информацию и принимать обоснованные решения.
- Адаптация: Позволение AI-системам адаптироваться к новым условиям и изменяющимся обстоятельствам.
- Восприятие: Повышение точности AI-систем в распознавании и интерпретации данных из окружающей среды.

### Что такое метапознание?

Метапознание, или "мышление о мышлении", — это высший когнитивный процесс, который включает самосознание и саморегуляцию своих когнитивных процессов. В области AI метапознание позволяет агентам оценивать и адаптировать свои стратегии и действия, что приводит к улучшению способностей к решению проблем и принятию решений. Понимая метапознание, вы можете разрабатывать AI-агентов, которые не только более интеллектуальны, но и более адаптивны и эффективны. В истинном метапознании вы увидите, как AI явно рассуждает о своих собственных рассуждениях.

Пример: "Я выбрал более дешевые рейсы, потому что... возможно, я упускаю прямые рейсы, так что давайте проверим еще раз."
Отслеживание того, как или почему был выбран определенный маршрут.
- Замечание, что были допущены ошибки из-за чрезмерного полагания на предпочтения пользователя с прошлого раза, поэтому он изменяет свою стратегию принятия решений, а не только окончательную рекомендацию.
- Диагностика таких шаблонов, как "Когда я вижу, что пользователь упоминает 'слишком многолюдно', я должен не только исключать определенные достопримечательности, но и понимать, что мой метод выбора 'лучших достопримечательностей' ошибочен, если я всегда ранжирую по популярности."

### Важность метапознания в AI-агентах

Метапознание играет ключевую роль в проектировании AI-агентов по нескольким причинам:

![Важность метапознания](../../../09-metacognition/images/importance-of-metacognition.png)

- Саморефлексия: Агенты могут оценивать свою собственную производительность и выявлять области для улучшения.
- Адаптивность: Агенты могут изменять свои стратегии на основе прошлого опыта и изменяющихся условий.
- Исправление ошибок: Агенты могут самостоятельно обнаруживать и исправлять ошибки, что приводит к более точным результатам.
- Управление ресурсами: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность, планируя и оценивая свои действия.

## Компоненты AI-агента

Прежде чем углубляться в метапознавательные процессы, важно понять основные компоненты AI-агента. AI-агент обычно состоит из:

- Персона: Личность и характеристики агента, которые определяют, как он взаимодействует с пользователями.
- Инструменты: Возможности и функции, которые агент может выполнять.
- Навыки: Знания и опыт, которыми обладает агент.

Эти компоненты работают вместе, создавая "единицу экспертизы", способную выполнять определенные задачи.

**Пример**:
Рассмотрим туристического агента, который не только планирует ваш отпуск, но и корректирует свой маршрут на основе данных в реальном времени и опыта предыдущих путешествий клиентов.

### Пример: Метапознание в туристическом агенте

Представьте, что вы разрабатываете туристическое агентство на базе AI. Этот агент, "Туристический агент", помогает пользователям планировать их отпуска. Чтобы включить метапознание, Туристический агент должен оценивать и корректировать свои действия на основе самосознания и прошлого опыта. Вот как метапознание может сыграть роль:

#### Текущая задача

Текущая задача — помочь пользователю спланировать поездку в Париж.

#### Шаги для выполнения задачи

1. **Сбор предпочтений пользователя**: Спросите пользователя о датах поездки, бюджете, интересах (например, музеи, кухня, шопинг) и любых специфических требованиях.
2. **Получение информации**: Найдите варианты рейсов, проживания, достопримечательностей и ресторанов, соответствующих предпочтениям пользователя.
3. **Создание рекомендаций**: Предоставьте персонализированный маршрут с деталями рейсов, бронированием отелей и предложенными мероприятиями.
4. **Корректировка на основе отзывов**: Попросите пользователя оставить отзыв о рекомендациях и внесите необходимые изменения.

#### Необходимые ресурсы

- Доступ к базам данных бронирования рейсов и отелей.
- Информация о парижских достопримечательностях и ресторанах.
- Данные отзывов пользователей из предыдущих взаимодействий.

#### Опыт и саморефлексия

Туристический агент использует метапознание для оценки своей производительности и обучения на основе прошлого опыта. Например:

1. **Анализ отзывов пользователей**: Туристический агент просматривает отзывы пользователей, чтобы определить, какие рекомендации были хорошо восприняты, а какие нет. Он корректирует свои будущие предложения соответственно.
2. **Адаптивность**: Если пользователь ранее упоминал о нелюбви к многолюдным местам, Туристический агент в будущем избегает рекомендовать популярные туристические места в часы пик.
3. **Исправление ошибок**: Если Туристический агент допустил ошибку в прошлом бронировании, например, предложив отель, который был полностью забронирован, он учится более тщательно проверять доступность перед тем, как делать рекомендации.

#### Практический пример для разработчиков

Вот упрощенный пример кода Туристического агента с использованием метапознания:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### Почему метапознание важно

- **Саморефлексия**: Агенты могут анализировать свою производительность и выявлять области для улучшения.
- **Адаптивность**: Агенты могут изменять стратегии на основе отзывов и изменяющихся условий.
- **Исправление ошибок**: Агенты могут самостоятельно обнаруживать и исправлять ошибки.
- **Управление ресурсами**: Агенты могут оптимизировать использование ресурсов, таких как время и вычислительная мощность.

Включив метапознание, Туристический агент может предоставлять более персонализированные и точные рекомендации по путешествиям, улучшая общий пользовательский опыт.

---

## 2. Планирование в агентах

Планирование — это критически важный компонент поведения AI-агента. Оно включает в себя определение шагов, необходимых для достижения цели, с учетом текущего состояния, ресурсов и возможных препятствий.

### Элементы планирования

- **Текущая задача**: Четко определите задачу.
- **Шаги для выполнения задачи**: Разбейте задачу на управляемые шаги.
- **Необходимые ресурсы**: Определите необходимые ресурсы.
- **Опыт**: Используйте прошлый опыт для информирования планирования.

**Пример**:
Вот шаги, которые Туристический агент должен предпринять, чтобы эффективно помочь пользователю в планировании поездки:

### Шаги для Туристического агента

1. **Сбор предпочтений пользователя**
   - Спросите пользователя о деталях его поездки, бюджете, интересах и любых специфических требованиях.
   - Примеры: "Когда вы планируете путешествовать?" "Какой у вас бюджет?" "Какие виды деятельности вам нравятся в отпуске?"

2. **Получение информации**
   - Найдите соответствующие варианты путешествий на основе предпочтений пользователя.
   - **Рейсы**: Ищите доступные рейсы в рамках бюджета пользователя и предпочитаемых дат поездки.
   - **Проживание**: Найдите отели или арендные объекты, соответствующие предпочтениям пользователя по местоположению, цене и удобствам.
   - **Достопримечательности и рестораны**: Определите популярные достопримечательности, мероприятия и варианты питания, соответствующие интересам пользователя.

3. **Создание рекомендаций**
   - Скомпилируйте полученную информацию в персонализированный маршрут.
   - Предоставьте детали, такие как варианты рейсов, бронирование отелей и предложенные мероприятия, убедившись, что рекомендации соответствуют предпочтениям пользователя.

4. **Представление маршрута пользователю**
   - Поделитесь предложенным маршрутом с пользователем для его рассмотрения.
   - Пример: "Вот предложенный маршрут для вашей поездки в Париж. Он включает детали рейсов, бронирование отелей и список рекомендованных мероприятий и ресторанов. Дайте знать, что вы думаете!"

5. **Сбор отзывов**
   - Попросите пользователя оставить отзыв о предложенном маршруте.
   - Примеры: "Вам нравятся варианты рейсов?" "Отель подходит для ваших нужд?" "Есть ли мероприятия, которые вы хотели бы добавить или удалить?"

6. **Корректировка на основе отзывов**
   - Измените маршрут на основе отзывов пользователя.
   - Внесите необходимые изменения в рекомендации по рейсам, проживанию и мероприятиям, чтобы лучше соответствовать предпочтениям пользователя.

7. **Окончательное подтверждение**
   - Представьте обновленный маршрут пользователю для окончательного подтверждения.
   - Пример: "Я внес изменения на основе ваших отзывов. Вот обновленный маршрут. Все ли вас устраивает?"

8. **Бронирование и подтверждение**
   - После того как пользователь одобрит маршрут, приступайте к бронированию рейсов, проживания и любых запланированных мероприятий.
   - Отправьте пользователю детали подтверждения.

9. **Предоставление постоянной поддержки**
   - Оставайтесь доступными, чтобы помочь пользователю с любыми изменениями или дополнительными запросами до и во время его поездки.
   - Пример: "Если вам понадобится дополнительная помощь во время поездки, не стесняйтесь обращаться ко мне в любое время!"

### Пример взаимодействия

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. Корректирующая система RAG

Сначала давайте начнем с понимания разницы между инструментом RAG и предварительной загрузкой контекста

![RAG vs Context Loading](../../../09-metacognition/images/rag-vs-context.png)

### Генерация с дополнением извлечением (RAG)

RAG сочетает в себе систему извлечения с генеративной моделью. Когда делается запрос, система извлечения получает соответствующие документы или данные из внешнего источника, и эта извлеченная информация используется для дополнения входных данных генеративной модели. Это помогает модели генерировать более точные и контекстуально релевантные ответы.

В системе RAG агент извлекает соответствующую информацию из базы знаний и использует ее для генерации подходящих ответов или действий.

### Корректирующий подход RAG

Корректирующий подход RAG фокусируется на использовании техник RAG для исправления ошибок и повышения точности AI-агентов. Это включает:

1. **Техника подсказок**: Использование специфических подсказок для направления агента в извлечении релевантной информации.
2. **Инструмент**: Реализация алгоритмов и механизмов, которые позволяют агенту оценивать релевантность извлеченной информации и генерировать точные ответы.
3. **Оценка**: Постоянная оценка производительности агента и внесение корректировок для повышения его точности и эффективности.

#### Пример: Корректирующий RAG в поисковом агенте

Рассмотрим поискового агента, который извлекает информацию из интернета для ответа на запросы пользователей. Корректирующий подход RAG может включать:

1. **Техника подсказок**: Формулирование поисковых запросов на основе ввода пользователя.
2. **Инструмент**: Использование алгоритмов обработки естественного языка и машинного обучения для ранжирования и фильтрации результатов поиска.
3. **Оценка**: Анализ отзывов пользователей для выявления и исправления неточностей в извлеченной информации.

### Корректирующий RAG в Туристическом агенте

Корректирующий RAG (Генерация с дополнением извлечением) улучшает способность AI извлекать и генерировать информацию, исправляя любые неточности. Давайте посмотрим, как Туристический агент может использовать корректирующий подход RAG для предоставления более точных и релевантных рекомендаций по путешествиям.

Это включает:

- **Техника подсказок**: Использование специфических подсказок для направления агента в извлечении релевантной информации.
- **Инструмент**: Реализация алгоритмов и механизмов, которые позволяют агенту оценивать релевантность извлеченной информации и генерировать точные ответы.
- **Оценка**: Постоянная оценка производительности агента и внесение корректировок для повышения его точности и эффективности.

#### Шаги для реализации корректирующего RAG в Туристическом агенте

1. **Первоначальное взаимодействие с пользователем**
   - Туристический агент собирает первоначальные предпочтения пользователя, такие как пункт назначения, даты поездки, бюджет и интересы.
   - Пример:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **Извлечение информации**
   - Туристический агент извлекает информацию о рейсах, проживании, достопримечательностях и ресторанах на основе предпочтений пользователя.
   - Пример:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **Создание первоначальных рекомендаций**
   - Туристический агент использует извлеченную информацию для создания персонализированного маршрута.
   - Пример:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **Сбор отзывов пользователей**
   - Туристический агент спрашивает пользователя о его отзывах на первоначальные рекомендации.
   - Пример:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **Процесс корректирующего RAG**
   - **Техника подсказок**: Туристический агент формулирует новые поисковые запросы на основе отзывов пользователя.
     - Пример:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **Инструмент**: Туристический агент использует алгоритмы для ранжирования и фильтрации новых результатов поиска, подчеркивая релевантность на основе отзывов пользователя.
     - Пример:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **Оценка**: Туристический агент постоянно оценивает релевантность и точность своих рекомендаций, анализируя отзывы пользователей и внося необходимые корректировки.
     - Пример:

       ```python
       def adjust_preferences(preferences, feedback):
           if "liked" in feedback:
               preferences["favorites"] = feedback["liked"]
           if "disliked" in feedback:
               preferences["avoid"] = feedback["disliked"]
           return preferences

       preferences = adjust_preferences(preferences, feedback)
       ```

#### Практический пример

Вот упрощенный пример кода на Python, включающий корректирующий подход RAG в Туристическом агенте:
```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)
        new_itinerary = self.generate_recommendations()
        return new_itinerary

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
new_itinerary = travel_agent.adjust_based_on_feedback(feedback)
print("Updated Itinerary:", new_itinerary)
```

### Предварительная загрузка контекста

Предварительная загрузка контекста включает в себя загрузку соответствующей информации или фона в модель до обработки запроса. Это означает, что модель имеет доступ к этой информации с самого начала, что может помочь ей генерировать более информированные ответы без необходимости извлекать дополнительные данные в процессе.

Вот упрощенный пример того, как может выглядеть предварительная загрузка контекста для приложения туристического агента на Python:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### Объяснение

1. **Инициализация (метод `__init__`)**: Класс `TravelAgent` предварительно загружает словарь, содержащий информацию о популярных направлениях, таких как Париж, Токио, Нью-Йорк и Сидней. Этот словарь включает такие детали, как страна, валюта, язык и основные достопримечательности для каждого направления.

2. **Извлечение информации (метод `get_destination_info`)**: Когда пользователь запрашивает информацию о конкретном направлении, метод `get_destination_info` извлекает соответствующую информацию из предварительно загруженного словаря контекста.

Благодаря предварительной загрузке контекста, приложение туристического агента может быстро отвечать на запросы пользователей, не извлекая эту информацию из внешнего источника в реальном времени. Это делает приложение более эффективным и отзывчивым.

### Инициализация плана с целью перед итерацией

Инициализация плана с целью включает в себя начало с четкой цели или желаемого результата. Определив эту цель заранее, модель может использовать ее в качестве руководящего принципа на протяжении всего итерационного процесса. Это помогает гарантировать, что каждая итерация приближает к достижению желаемого результата, делая процесс более эффективным и целенаправленным.

Вот пример того, как можно инициализировать план путешествия с целью перед итерацией для туристического агента на Python:

### Сценарий

Туристический агент хочет спланировать индивидуальный отпуск для клиента. Цель — создать маршрут путешествия, который максимально удовлетворит клиента, основываясь на его предпочтениях и бюджете.

### Шаги

1. Определите предпочтения и бюджет клиента.
2. Инициализируйте начальный план на основе этих предпочтений.
3. Итеративно уточняйте план, оптимизируя его для удовлетворения клиента.

#### Код на Python

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### Объяснение кода

1. **Инициализация (метод `__init__`)**: Класс `TravelAgent` инициализируется списком потенциальных направлений, каждое из которых имеет такие атрибуты, как название, стоимость и тип активности.

2. **Инициализация плана (метод `bootstrap_plan`)**: Этот метод создает начальный план путешествия на основе предпочтений и бюджета клиента. Он проходит по списку направлений и добавляет их в план, если они соответствуют предпочтениям клиента и укладываются в бюджет.

3. **Сопоставление предпочтений (метод `match_preferences`)**: Этот метод проверяет, соответствует ли направление предпочтениям клиента.

4. **Итерация плана (метод `iterate_plan`)**: Этот метод уточняет начальный план, пытаясь заменить каждое направление в плане на более подходящее, учитывая предпочтения клиента и бюджетные ограничения.

5. **Расчет стоимости (метод `calculate_cost`)**: Этот метод рассчитывает общую стоимость текущего плана, включая потенциальное новое направление.

#### Пример использования

- **Начальный план**: Туристический агент создает начальный план на основе предпочтений клиента по осмотру достопримечательностей и бюджета в $2000.
- **Уточненный план**: Туристический агент итеративно уточняет план, оптимизируя его для предпочтений и бюджета клиента.

Инициализируя план с четкой целью (например, максимизация удовлетворенности клиента) и итеративно уточняя план, туристический агент может создать индивидуальный и оптимизированный маршрут путешествия для клиента. Этот подход гарантирует, что план путешествия соответствует предпочтениям и бюджету клиента с самого начала и улучшается с каждой итерацией.

### Использование LLM для переоценки и оценки

Большие языковые модели (LLM) могут использоваться для переоценки и оценки, оценивая релевантность и качество извлеченных документов или сгенерированных ответов. Вот как это работает:

**Извлечение:** На начальном этапе извлечения выбирается набор кандидатов-документов или ответов на основе запроса.

**Переоценка:** LLM оценивает этих кандидатов и переоценивает их на основе их релевантности и качества. Этот шаг гарантирует, что наиболее релевантная и качественная информация представлена первой.

**Оценка:** LLM присваивает каждому кандидату оценки, отражающие их релевантность и качество. Это помогает выбрать лучший ответ или документ для пользователя.

Используя LLM для переоценки и оценки, система может предоставлять более точную и контекстуально релевантную информацию, улучшая общий пользовательский опыт.

Вот пример того, как туристический агент может использовать Большую Языковую Модель (LLM) для переоценки и оценки туристических направлений на основе предпочтений пользователя на Python:

#### Сценарий - Путешествие на основе предпочтений

Туристический агент хочет порекомендовать клиенту лучшие туристические направления на основе его предпочтений. LLM поможет переоценить и оценить направления, чтобы гарантировать, что представлены наиболее релевантные варианты.

#### Шаги:

1. Соберите предпочтения пользователя.
2. Извлеките список потенциальных туристических направлений.
3. Используйте LLM для переоценки и оценки направлений на основе предпочтений пользователя.

Вот как вы можете обновить предыдущий пример, чтобы использовать Azure OpenAI Services:

#### Требования

1. Вам нужна подписка Azure.
2. Создайте ресурс Azure OpenAI и получите свой API-ключ.

#### Пример кода на Python

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### Объяснение кода - Бронирование предпочтений

1. **Инициализация**: Класс `TravelAgent` инициализируется списком потенциальных туристических направлений, каждое из которых имеет такие атрибуты, как название и описание.

2. **Получение рекомендаций (метод `get_recommendations`)**: Этот метод генерирует запрос для сервиса Azure OpenAI на основе предпочтений пользователя и делает HTTP POST-запрос к API Azure OpenAI для получения переоцененных и оцененных направлений.

3. **Генерация запроса (метод `generate_prompt`)**: Этот метод создает запрос для Azure OpenAI, включая предпочтения пользователя и список направлений. Запрос направляет модель на переоценку и оценку направлений на основе предоставленных предпочтений.

4. **API-запрос**: Библиотека `requests` используется для выполнения HTTP POST-запроса к конечной точке API Azure OpenAI. Ответ содержит переоцененные и оцененные направления.

5. **Пример использования**: Туристический агент собирает предпочтения пользователя (например, интерес к осмотру достопримечательностей и разнообразной культуре) и использует сервис Azure OpenAI для получения переоцененных и оцененных рекомендаций по туристическим направлениям.

Убедитесь, что заменили `your_azure_openai_api_key` на ваш фактический API-ключ Azure OpenAI и `https://your-endpoint.com/...` на фактический URL конечной точки вашего развертывания Azure OpenAI.

Используя LLM для переоценки и оценки, туристический агент может предоставлять более персонализированные и релевантные рекомендации по путешествиям клиентам, улучшая их общий опыт.

### RAG: Техника подсказки против инструмента

Генерация с дополнением извлечением (RAG) может быть как техникой подсказки, так и инструментом в разработке AI-агентов. Понимание различия между ними может помочь вам более эффективно использовать RAG в ваших проектах.

#### RAG как техника подсказки

**Что это?**

- Как техника подсказки, RAG включает формулирование конкретных запросов или подсказок для направления извлечения релевантной информации из большого корпуса или базы данных. Эта информация затем используется для генерации ответов или действий.

**Как это работает:**

1. **Формулирование подсказок**: Создайте хорошо структурированные подсказки или запросы на основе задачи или ввода пользователя.
2. **Извлечение информации**: Используйте подсказки для поиска релевантных данных из существующей базы знаний или набора данных.
3. **Генерация ответа**: Объедините извлеченную информацию с генеративными AI-моделями для создания комплексного и связного ответа.

**Пример в туристическом агенте**:

- Ввод пользователя: "Я хочу посетить музеи в Париже."
- Подсказка: "Найти лучшие музеи в Париже."
- Извлеченная информация: Информация о Лувре, Музее Орсе и т.д.
- Сгенерированный ответ: "Вот некоторые из лучших музеев в Париже: Лувр, Музей Орсе и Центр Помпиду."

#### RAG как инструмент

**Что это?**

- Как инструмент, RAG представляет собой интегрированную систему, которая автоматизирует процесс извлечения и генерации, облегчая разработчикам реализацию сложных AI-функций без необходимости вручную создавать подсказки для каждого запроса.

**Как это работает:**

1. **Интеграция**: Встроить RAG в архитектуру AI-агента, позволяя ему автоматически обрабатывать задачи извлечения и генерации.
2. **Автоматизация**: Инструмент управляет всем процессом, от получения ввода пользователя до генерации окончательного ответа, без необходимости явных подсказок для каждого шага.
3. **Эффективность**: Повышает производительность агента, упрощая процесс извлечения и генерации, обеспечивая более быстрые и точные ответы.

**Пример в туристическом агенте**:

- Ввод пользователя: "Я хочу посетить музеи в Париже."
- Инструмент RAG: Автоматически извлекает информацию о музеях и генерирует ответ.
- Сгенерированный ответ: "Вот некоторые из лучших музеев в Париже: Лувр, Музей Орсе и Центр Помпиду."

### Сравнение

| Аспект                 | Техника подсказки                                        | Инструмент                                                  |
|------------------------|----------------------------------------------------------|-------------------------------------------------------------|
| **Ручное vs Автоматическое**| Ручная формулировка подсказок для каждого запроса.   | Автоматизированный процесс извлечения и генерации.          |
| **Контроль**            | Предоставляет больше контроля над процессом извлечения. | Упрощает и автоматизирует процесс извлечения и генерации.   |
| **Гибкость**           | Позволяет создавать индивидуальные подсказки на основе конкретных нужд. | Более эффективен для крупномасштабных реализаций.          |
| **Сложность**          | Требует создания и настройки подсказок.                  | Легче интегрируется в архитектуру AI-агента.                |

### Практические примеры

**Пример техники подсказки:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**Пример инструмента:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### Оценка релевантности

Оценка релевантности — это важный аспект производительности AI-агента. Она гарантирует, что информация, извлеченная и сгенерированная агентом, является подходящей, точной и полезной для пользователя. Давайте рассмотрим, как оценивать релевантность в AI-агентах, включая практические примеры и техники.

#### Основные концепции в оценке релевантности

1. **Осведомленность о контексте**:
   - Агент должен понимать контекст запроса пользователя, чтобы извлечь и сгенерировать релевантную информацию.
   - Пример: Если пользователь спрашивает о "лучших ресторанах в Париже", агент должен учитывать предпочтения пользователя, такие как тип кухни и бюджет.

2. **Точность**:
   - Информация, предоставляемая агентом, должна быть фактически правильной и актуальной.
   - Пример: Рекомендовать открытые рестораны с хорошими отзывами, а не устаревшие или закрытые варианты.

3. **Намерение пользователя**:
   - Агент должен улавливать намерение пользователя за запросом, чтобы предоставить наиболее релевантную информацию.
   - Пример: Если пользователь спрашивает о "доступных отелях", агент должен отдавать приоритет доступным вариантам.

4. **Цикл обратной связи**:
   - Постоянный сбор и анализ обратной связи от пользователей помогает агенту улучшать процесс оценки релевантности.
   - Пример: Включение оценок и отзывов пользователей о предыдущих рекомендациях для улучшения будущих ответов.

#### Практические техники для оценки релевантности

1. **Оценка релевантности**:
   - Присваивайте оценку релевантности каждому извлеченному элементу на основе того, насколько хорошо он соответствует запросу и предпочтениям пользователя.
   - Пример:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **Фильтрация и ранжирование**:
   - Отфильтровывайте нерелевантные элементы и ранжируйте оставшиеся на основе их оценок релевантности.
   - Пример:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **Обработка естественного языка (NLP)**:
   - Используйте техники NLP для понимания запроса пользователя и извлечения релевантной информации.
   - Пример:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **Интеграция обратной связи от пользователей**:
   - Собирайте обратную связь от пользователей о предоставленных рекомендациях и используйте ее для корректировки будущих оценок релевантности.
   - Пример:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### Пример: Оценка релевантности в туристическом агенте

Вот практический пример того, как туристический агент может оценивать релевантность туристических рекомендаций:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### Поиск с учетом намерения

Поиск с учетом намерения включает в себя понимание и интерпретацию основной цели или задачи, стоящей за запросом пользователя, для извлечения и генерации наиболее релевантной и полезной информации. Этот подход выходит за рамки простого сопоставления ключевых слов и фокусируется на понимании реальных нужд и контекста пользователя.

#### Основные концепции в поиске с учетом намерения

1. **Понимание намерения пользователя**:
   - Намерение пользователя можно разделить на три основные категории: информационное, навигационное и транзакционное.
     - **Информационное намерение**: Пользователь ищет информацию о теме (например, "Какие лучшие музеи в Париже?").
     - **Навигационное намерение**: Пользователь хочет перейти на конкретный сайт или страницу (например, "Официальный сайт Лувра").
     - **Транзакционное намерение**: Пользователь хочет совершить транзакцию, такую как бронирование рейса или покупка (например, "Забронировать рейс в Париж").

2. **Осведомленность о контексте**:
   - Анализ контекста запроса пользователя помогает точно определить его намерение. Это включает в себя учет предыдущих взаимодействий, предпочтений пользователя и конкретных деталей текущего запроса.

3. **Обработка естественного языка (NLP)**:
   - Техники NLP используются для понимания и интерпретации естественных языковых запросов, предоставляемых пользователями. Это включает задачи, такие как распознавание сущностей, анализ настроений и разбор запросов.

4. **Персонализация**:
   - Персонализация результатов поиска на основе истории пользователя, предпочтений и обратной связи улучшает релевантность извлеченной информации.
#### Практический пример: Поиск с учетом намерений в Travel Agent

Рассмотрим пример Travel Agent, чтобы увидеть, как можно реализовать поиск с учетом намерений.

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Понимание намерений пользователя**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **Осведомленность о контексте**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **Поиск и персонализация результатов**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **Пример использования**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. Генерация кода как инструмент

Агенты, генерирующие код, используют модели ИИ для написания и выполнения кода, решая сложные задачи и автоматизируя процессы.

### Агенты, генерирующие код

Агенты, генерирующие код, используют генеративные модели ИИ для написания и выполнения кода. Эти агенты могут решать сложные задачи, автоматизировать процессы и предоставлять ценные инсайты, генерируя и выполняя код на различных языках программирования.

#### Практические приложения

1. **Автоматическая генерация кода**: Генерация фрагментов кода для конкретных задач, таких как анализ данных, веб-скрапинг или машинное обучение.
2. **SQL как RAG**: Использование SQL-запросов для извлечения и манипуляции данными из баз данных.
3. **Решение проблем**: Создание и выполнение кода для решения конкретных задач, таких как оптимизация алгоритмов или анализ данных.

#### Пример: Агент, генерирующий код для анализа данных

Представьте, что вы разрабатываете агента, генерирующего код. Вот как это может работать:

1. **Задача**: Анализировать набор данных для выявления трендов и закономерностей.
2. **Шаги**:
   - Загрузить набор данных в инструмент анализа данных.
   - Сгенерировать SQL-запросы для фильтрации и агрегации данных.
   - Выполнить запросы и получить результаты.
   - Использовать результаты для создания визуализаций и инсайтов.
3. **Необходимые ресурсы**: Доступ к набору данных, инструменты анализа данных и возможности SQL.
4. **Опыт**: Использовать результаты прошлых анализов для улучшения точности и релевантности будущих анализов.

### Пример: Агент, генерирующий код для Travel Agent

В этом примере мы разработаем агента, генерирующего код, Travel Agent, чтобы помочь пользователям в планировании путешествий, генерируя и выполняя код. Этот агент может выполнять такие задачи, как поиск вариантов путешествий, фильтрация результатов и составление маршрута с использованием генеративного ИИ.

#### Обзор агента, генерирующего код

1. **Сбор предпочтений пользователя**: Сбор данных от пользователя, таких как пункт назначения, даты поездки, бюджет и интересы.
2. **Генерация кода для получения данных**: Генерация фрагментов кода для получения данных о рейсах, отелях и достопримечательностях.
3. **Выполнение сгенерированного кода**: Выполнение сгенерированного кода для получения актуальной информации.
4. **Генерация маршрута**: Составление персонализированного плана путешествия на основе полученных данных.
5. **Корректировка на основе отзывов**: Получение отзывов от пользователя и повторная генерация кода при необходимости для уточнения результатов.

#### Пошаговая реализация

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация кода для получения данных**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **Выполнение сгенерированного кода**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **Генерация маршрута**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **Корректировка на основе отзывов**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### Использование осведомленности об окружающей среде и рассуждений

На основе схемы таблицы можно улучшить процесс генерации запросов, используя осведомленность об окружающей среде и рассуждения.

Вот пример, как это можно сделать:

1. **Понимание схемы**: Система будет понимать схему таблицы и использовать эту информацию для обоснования генерации запросов.
2. **Корректировка на основе отзывов**: Система будет корректировать предпочтения пользователя на основе отзывов и рассуждать, какие поля в схеме нужно обновить.
3. **Генерация и выполнение запросов**: Система будет генерировать и выполнять запросы для получения обновленных данных о рейсах и отелях на основе новых предпочтений.

Вот обновленный пример кода на Python, который включает эти концепции:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### Объяснение - Бронирование на основе отзывов

1. **Осведомленность о схеме**: Словарь `schema` определяет, как предпочтения должны корректироваться на основе отзывов. Он включает такие поля, как `favorites` и `avoid`, с соответствующими корректировками.
2. **Корректировка предпочтений (метод `adjust_based_on_feedback`)**: Этот метод корректирует предпочтения на основе отзывов пользователей и схемы.
3. **Корректировки на основе окружающей среды (метод `adjust_based_on_environment`)**: Этот метод настраивает корректировки на основе схемы и отзывов.
4. **Генерация и выполнение запросов**: Система генерирует код для получения обновленных данных о рейсах и отелях на основе скорректированных предпочтений и симулирует выполнение этих запросов.
5. **Генерация маршрута**: Система создает обновленный маршрут на основе новых данных о рейсах, отелях и достопримечательностях.

Благодаря тому, что система осведомлена об окружающей среде и использует рассуждения на основе схемы, она может генерировать более точные и релевантные запросы, что приводит к лучшим рекомендациям по путешествиям и более персонализированному пользовательскому опыту.

### Использование SQL как техники Retrieval-Augmented Generation (RAG)

SQL (язык структурированных запросов) — это мощный инструмент для взаимодействия с базами данных. Когда он используется как часть подхода Retrieval-Augmented Generation (RAG), SQL может извлекать релевантные данные из баз данных для информирования и генерации ответов или действий в ИИ-агентах. Давайте рассмотрим, как SQL может использоваться как техника RAG в контексте Travel Agent.

#### Основные концепции

1. **Взаимодействие с базой данных**:
   - SQL используется для выполнения запросов к базам данных, извлечения релевантной информации и манипуляции данными.
   - Пример: Извлечение информации о рейсах, отелях и достопримечательностях из базы данных путешествий.

2. **Интеграция с RAG**:
   - SQL-запросы генерируются на основе ввода и предпочтений пользователя.
   - Извлеченные данные затем используются для генерации персонализированных рекомендаций или действий.

3. **Динамическая генерация запросов**:
   - ИИ-агент генерирует динамические SQL-запросы на основе контекста и потребностей пользователя.
   - Пример: Настройка SQL-запросов для фильтрации результатов на основе бюджета, дат и интересов.

#### Приложения

- **Автоматическая генерация кода**: Генерация фрагментов кода для конкретных задач.
- **SQL как RAG**: Использование SQL-запросов для манипуляции данными.
- **Решение проблем**: Создание и выполнение кода для решения проблем.

**Пример**:
Агент анализа данных:

1. **Задача**: Анализировать набор данных для поиска трендов.
2. **Шаги**:
   - Загрузить набор данных.
   - Сгенерировать SQL-запросы для фильтрации данных.
   - Выполнить запросы и получить результаты.
   - Создать визуализации и инсайты.
3. **Ресурсы**: Доступ к набору данных, возможности SQL.
4. **Опыт**: Использовать прошлые результаты для улучшения будущих анализов.

#### Практический пример: Использование SQL в Travel Agent

1. **Сбор предпочтений пользователя**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **Генерация SQL-запросов**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **Выполнение SQL-запросов**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **Генерация рекомендаций**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### Примеры SQL-запросов

1. **Запрос рейсов**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **Запрос отелей**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **Запрос достопримечательностей**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Используя SQL как часть техники Retrieval-Augmented Generation (RAG), такие ИИ-агенты, как Travel Agent, могут динамически извлекать и использовать релевантные данные для предоставления точных и персонализированных рекомендаций.

### Пример метакогниции

Чтобы продемонстрировать реализацию метакогниции, давайте создадим простого агента, который *размышляет о своем процессе принятия решений* при решении проблемы. В этом примере мы создадим систему, где агент пытается оптимизировать выбор отеля, но затем оценивает свои собственные рассуждения и корректирует свою стратегию, когда делает ошибки или выбирает не оптимальные варианты.

Мы смоделируем это с помощью простого примера, где агент выбирает отели на основе сочетания цены и качества, но будет "размышлять" о своих решениях и корректировать их соответственно.

#### Как это иллюстрирует метакогницию:

1. **Первоначальное решение**: Агент выберет самый дешевый отель, не понимая влияния на качество.
2. **Размышление и оценка**: После первоначального выбора агент проверит, является ли отель "плохим" выбором, используя отзывы пользователей. Если он обнаружит, что качество отеля было слишком низким, он размышляет о своих рассуждениях.
3. **Корректировка стратегии**: Агент корректирует свою стратегию на основе размышлений, переключаясь с "самого дешевого" на "самое высокое качество", таким образом улучшая свой процесс принятия решений в будущих итерациях.

Вот пример:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### Способности метакогниции агентов

Ключевым моментом здесь является способность агента:
- Оценивать свои предыдущие выборы и процесс принятия решений.
- Корректировать свою стратегию на основе этих размышлений, то есть метакогниция в действии.

Это простая форма метакогниции, где система способна корректировать свой процесс рассуждений на основе внутренней обратной связи.

### Заключение

Метакогниция — это мощный инструмент, который может значительно улучшить возможности ИИ-агентов. Внедряя метакогнитивные процессы, вы можете разрабатывать агентов, которые более интеллектуальны, адаптивны и эффективны. Используйте дополнительные ресурсы, чтобы глубже изучить увлекательный мир метакогниции в ИИ-агентах.

## Предыдущий урок

[Шаблон проектирования с несколькими агентами](../08-multi-agent/README.md)

## Следующий урок

[ИИ-агенты в производстве](../10-ai-agents-production/README.md)

**Отказ от ответственности**:  
Этот документ был переведен с помощью службы автоматического перевода [Co-op Translator](https://github.com/Azure/co-op-translator). Хотя мы стремимся к точности, пожалуйста, имейте в виду, что автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его родном языке следует считать авторитетным источником. Для получения критически важной информации рекомендуется профессиональный перевод человеком. Мы не несем ответственности за любые недоразумения или неправильные толкования, возникающие в результате использования этого перевода.