<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5cc6836626047aa055e8960c8484a7d0",
  "translation_date": "2025-08-21T13:21:28+00:00",
  "source_file": "11-mcp/code_samples/mcp-agents/README.md",
  "language_code": "th"
}
-->
# การสร้างระบบการสื่อสารระหว่างเอเจนต์ด้วย MCP

> สรุปสั้นๆ - คุณสามารถสร้างการสื่อสารระหว่างเอเจนต์บน MCP ได้หรือไม่? ได้แน่นอน!

MCP ได้พัฒนาไปไกลเกินกว่าเป้าหมายเริ่มต้นที่เป็นเพียง "การให้บริบทแก่ LLMs" ด้วยการปรับปรุงล่าสุด เช่น [resumable streams](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery), [elicitation](https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation), [sampling](https://modelcontextprotocol.io/specification/2025-06-18/client/sampling) และการแจ้งเตือน ([progress](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress) และ [resources](https://modelcontextprotocol.io/specification/2025-06-18/schema#resourceupdatednotification)) MCP ได้กลายเป็นรากฐานที่แข็งแกร่งสำหรับการสร้างระบบการสื่อสารระหว่างเอเจนต์ที่ซับซ้อน

## ความเข้าใจผิดเกี่ยวกับ Agent/Tool

เมื่อมีนักพัฒนาจำนวนมากขึ้นที่สำรวจเครื่องมือที่มีพฤติกรรมแบบเอเจนต์ (ทำงานเป็นเวลานาน อาจต้องการข้อมูลเพิ่มเติมระหว่างการทำงาน ฯลฯ) ความเข้าใจผิดที่พบบ่อยคือ MCP ไม่เหมาะสม เนื่องจากตัวอย่างแรกๆ ของ primitive tools ของ MCP มุ่งเน้นไปที่รูปแบบการตอบสนองแบบง่ายๆ

ความเข้าใจนี้ล้าสมัยไปแล้ว สเปคของ MCP ได้รับการปรับปรุงอย่างมากในช่วงไม่กี่เดือนที่ผ่านมา โดยเพิ่มความสามารถที่ช่วยให้สามารถสร้างพฤติกรรมแบบเอเจนต์ที่ทำงานเป็นเวลานานได้:

- **Streaming & Partial Results**: อัปเดตความคืบหน้าแบบเรียลไทม์ระหว่างการทำงาน
- **Resumability**: ไคลเอนต์สามารถเชื่อมต่อใหม่และดำเนินการต่อหลังจากการตัดการเชื่อมต่อ
- **Durability**: ผลลัพธ์ยังคงอยู่แม้เซิร์ฟเวอร์จะรีสตาร์ท (เช่น ผ่าน resource links)
- **Multi-turn**: การป้อนข้อมูลแบบโต้ตอบระหว่างการทำงานผ่าน elicitation และ sampling

คุณสมบัติเหล่านี้สามารถนำมาประกอบกันเพื่อสร้างแอปพลิเคชันแบบเอเจนต์และหลายเอเจนต์ที่ซับซ้อน ซึ่งทั้งหมดนี้สามารถปรับใช้บนโปรโตคอล MCP ได้

สำหรับการอ้างอิง เราจะเรียกเอเจนต์ว่าเป็น "เครื่องมือ" ที่มีอยู่บนเซิร์ฟเวอร์ MCP ซึ่งหมายถึงการมีอยู่ของแอปพลิเคชันโฮสต์ที่ใช้งาน MCP client เพื่อสร้างเซสชันกับเซิร์ฟเวอร์ MCP และสามารถเรียกใช้งานเอเจนต์ได้

## อะไรที่ทำให้เครื่องมือ MCP มีลักษณะ "Agentic"?

ก่อนที่จะลงลึกถึงการใช้งาน เรามากำหนดความสามารถของโครงสร้างพื้นฐานที่จำเป็นสำหรับการสนับสนุนเอเจนต์ที่ทำงานเป็นเวลานาน

> เราจะกำหนดเอเจนต์ว่าเป็นเอนทิตีที่สามารถทำงานได้อย่างอิสระในระยะเวลานาน มีความสามารถในการจัดการงานที่ซับซ้อนซึ่งอาจต้องการการโต้ตอบหรือการปรับเปลี่ยนหลายครั้งตามข้อมูลย้อนกลับแบบเรียลไทม์

### 1. Streaming & Partial Results

รูปแบบการตอบสนองแบบดั้งเดิมไม่เหมาะสำหรับงานที่ใช้เวลานาน เอเจนต์จำเป็นต้องให้:

- การอัปเดตความคืบหน้าแบบเรียลไทม์
- ผลลัพธ์ระหว่างทาง

**การสนับสนุน MCP**: การแจ้งเตือนการอัปเดตทรัพยากรช่วยให้สามารถสตรีมผลลัพธ์บางส่วนได้ แต่ต้องมีการออกแบบอย่างรอบคอบเพื่อหลีกเลี่ยงความขัดแย้งกับโมเดลการร้องขอ/ตอบสนอง 1:1 ของ JSON-RPC

| คุณสมบัติ                | กรณีการใช้งาน                                                                                                                                                                       | การสนับสนุน MCP                                                                          |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| การอัปเดตความคืบหน้าแบบเรียลไทม์ | ผู้ใช้ร้องขอการย้ายโค้ดเบส เอเจนต์สตรีมความคืบหน้า: "10% - กำลังวิเคราะห์ dependencies... 25% - กำลังแปลงไฟล์ TypeScript... 50% - กำลังอัปเดต imports..."          | ✅ การแจ้งเตือนความคืบหน้า                                                              |
| ผลลัพธ์บางส่วน            | งาน "สร้างหนังสือ" สตรีมผลลัพธ์บางส่วน เช่น 1) โครงเรื่อง 2) รายการบท 3) แต่ละบทเมื่อเสร็จสมบูรณ์ โฮสต์สามารถตรวจสอบ ยกเลิก หรือเปลี่ยนเส้นทางในแต่ละขั้นตอน | ✅ การแจ้งเตือนสามารถ "ขยาย" เพื่อรวมผลลัพธ์บางส่วน ดูข้อเสนอใน PR 383, 776          |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 1:</strong> แผนภาพนี้แสดงให้เห็นว่าเอเจนต์ MCP สตรีมการอัปเดตความคืบหน้าแบบเรียลไทม์และผลลัพธ์บางส่วนไปยังแอปพลิเคชันโฮสต์ระหว่างงานที่ใช้เวลานาน ช่วยให้ผู้ใช้สามารถติดตามการทำงานได้แบบเรียลไทม์
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)

    User->>Host: Start long task
    Host->>Server: Call agent_tool()

    loop Progress Updates
        Server-->>Host: Progress + partial results
        Host-->>User: Stream updates
    end

    Server-->>Host: ✅ Final result
    Host-->>User: Complete
```

### 2. Resumability

เอเจนต์ต้องจัดการกับการขัดจังหวะของเครือข่ายได้อย่างราบรื่น:

- เชื่อมต่อใหม่หลังจากการตัดการเชื่อมต่อ (ของไคลเอนต์)
- ดำเนินการต่อจากจุดที่หยุดไว้ (การส่งข้อความซ้ำ)

**การสนับสนุน MCP**: MCP StreamableHTTP transport ในปัจจุบันรองรับการกลับมาเชื่อมต่อเซสชันและการส่งข้อความซ้ำด้วย session IDs และ last event IDs สิ่งสำคัญคือเซิร์ฟเวอร์ต้องมีการใช้งาน EventStore ที่ช่วยให้สามารถเล่นเหตุการณ์ซ้ำได้เมื่อไคลเอนต์เชื่อมต่อใหม่  
มีข้อเสนอจากชุมชน (PR #975) ที่สำรวจการสตรีมที่สามารถกลับมาเชื่อมต่อได้โดยไม่ขึ้นกับ transport

| คุณสมบัติ      | กรณีการใช้งาน                                                                                                                                                   | การสนับสนุน MCP                                                        |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Resumability     | ไคลเอนต์ตัดการเชื่อมต่อระหว่างงานที่ใช้เวลานาน เมื่อเชื่อมต่อใหม่ เซสชันจะกลับมาทำงานต่อพร้อมเหตุการณ์ที่พลาดไปถูกเล่นซ้ำ ทำให้ดำเนินการต่อได้อย่างราบรื่น | ✅ StreamableHTTP transport พร้อม session IDs, การเล่นเหตุการณ์ซ้ำ และ EventStore |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 2:</strong> แผนภาพนี้แสดงให้เห็นว่า StreamableHTTP transport และ event store ของ MCP ช่วยให้การกลับมาเชื่อมต่อเซสชันเป็นไปอย่างราบรื่น: หากไคลเอนต์ตัดการเชื่อมต่อ สามารถเชื่อมต่อใหม่และเล่นเหตุการณ์ที่พลาดไปได้ ทำให้งานดำเนินต่อไปโดยไม่สูญเสียความคืบหน้า
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)
    participant Store as Event Store

    User->>Host: Start task
    Host->>Server: Call tool [session: abc123]
    Server->>Store: Save events

    Note over Host,Server: 💥 Connection lost

    Host->>Server: Reconnect [session: abc123]
    Store-->>Server: Replay events
    Server-->>Host: Catch up + continue
    Host-->>User: ✅ Complete
```

### 3. Durability

เอเจนต์ที่ทำงานเป็นเวลานานต้องการสถานะที่คงทน:

- ผลลัพธ์ยังคงอยู่แม้เซิร์ฟเวอร์จะรีสตาร์ท
- สามารถดึงสถานะได้จากภายนอก
- การติดตามความคืบหน้าข้ามเซสชัน

**การสนับสนุน MCP**: MCP ปัจจุบันรองรับประเภทการคืนค่า Resource link สำหรับการเรียกใช้เครื่องมือ... 

(เนื้อหาที่เหลือจะถูกแปลในลักษณะเดียวกัน)

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้อง แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่แม่นยำ เอกสารต้นฉบับในภาษาดั้งเดิมควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ แนะนำให้ใช้บริการแปลภาษาจากผู้เชี่ยวชาญที่เป็นมนุษย์ เราจะไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความที่ผิดพลาดซึ่งเกิดจากการใช้การแปลนี้