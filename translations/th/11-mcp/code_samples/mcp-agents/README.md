<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5cc6836626047aa055e8960c8484a7d0",
  "translation_date": "2025-07-24T09:51:25+00:00",
  "source_file": "11-mcp/code_samples/mcp-agents/README.md",
  "language_code": "th"
}
-->
# การสร้างระบบการสื่อสารระหว่างเอเจนต์ด้วย MCP

> สรุปสั้นๆ - คุณสามารถสร้างการสื่อสารระหว่างเอเจนต์บน MCP ได้หรือไม่? คำตอบคือ ได้!

MCP ได้พัฒนาไปไกลเกินกว่าเป้าหมายเริ่มต้นที่เป็นเพียง "การให้บริบทแก่ LLMs" ด้วยการปรับปรุงล่าสุด เช่น [resumable streams](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery), [elicitation](https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation), [sampling](https://modelcontextprotocol.io/specification/2025-06-18/client/sampling) และการแจ้งเตือน ([progress](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress) และ [resources](https://modelcontextprotocol.io/specification/2025-06-18/schema#resourceupdatednotification)) MCP ได้กลายเป็นรากฐานที่แข็งแกร่งสำหรับการสร้างระบบการสื่อสารระหว่างเอเจนต์ที่ซับซ้อน

## ความเข้าใจผิดเกี่ยวกับ Agent/Tool

เมื่อมีนักพัฒนาจำนวนมากขึ้นที่สำรวจเครื่องมือที่มีพฤติกรรมแบบเอเจนต์ (ทำงานเป็นเวลานาน อาจต้องการข้อมูลเพิ่มเติมระหว่างการทำงาน ฯลฯ) ความเข้าใจผิดที่พบบ่อยคือ MCP ไม่เหมาะสม เนื่องจากตัวอย่างแรกๆ ของ primitive tools ของ MCP มุ่งเน้นไปที่รูปแบบการตอบสนองแบบง่ายๆ

ความเข้าใจนี้ล้าสมัยไปแล้ว สเปคของ MCP ได้รับการปรับปรุงอย่างมากในช่วงไม่กี่เดือนที่ผ่านมา โดยเพิ่มความสามารถที่ช่วยให้สามารถสร้างพฤติกรรมแบบเอเจนต์ที่ทำงานระยะยาวได้:

- **Streaming & Partial Results**: อัปเดตความคืบหน้าแบบเรียลไทม์ระหว่างการทำงาน
- **Resumability**: ลูกค้าสามารถเชื่อมต่อใหม่และดำเนินการต่อหลังจากการตัดการเชื่อมต่อ
- **Durability**: ผลลัพธ์ยังคงอยู่แม้เซิร์ฟเวอร์จะรีสตาร์ท (เช่น ผ่าน resource links)
- **Multi-turn**: การป้อนข้อมูลแบบโต้ตอบระหว่างการทำงานผ่าน elicitation และ sampling

คุณสมบัติเหล่านี้สามารถนำมาประกอบกันเพื่อสร้างแอปพลิเคชันแบบเอเจนต์และหลายเอเจนต์ที่ซับซ้อน ซึ่งทั้งหมดนี้สามารถปรับใช้บนโปรโตคอล MCP ได้

สำหรับการอ้างอิง เราจะเรียกเอเจนต์ว่าเป็น "เครื่องมือ" ที่มีอยู่บนเซิร์ฟเวอร์ MCP ซึ่งหมายถึงการมีอยู่ของแอปพลิเคชันโฮสต์ที่ใช้งาน MCP client เพื่อสร้างเซสชันกับเซิร์ฟเวอร์ MCP และสามารถเรียกใช้งานเอเจนต์ได้

## อะไรที่ทำให้ MCP Tool มีความเป็น "Agentic"?

ก่อนที่จะเข้าสู่การใช้งาน เรามากำหนดความสามารถของโครงสร้างพื้นฐานที่จำเป็นสำหรับการสนับสนุนเอเจนต์ที่ทำงานระยะยาว

> เราจะกำหนดเอเจนต์ว่าเป็นเอนทิตีที่สามารถทำงานได้อย่างอิสระในระยะเวลานาน มีความสามารถในการจัดการงานที่ซับซ้อนซึ่งอาจต้องการการโต้ตอบหรือการปรับเปลี่ยนหลายครั้งตามข้อมูลป้อนกลับแบบเรียลไทม์

### 1. Streaming & Partial Results

รูปแบบการตอบสนองแบบดั้งเดิมไม่เหมาะสำหรับงานที่ใช้เวลานาน เอเจนต์จำเป็นต้องให้:

- การอัปเดตความคืบหน้าแบบเรียลไทม์
- ผลลัพธ์ระหว่างทาง

**การสนับสนุน MCP**: การแจ้งเตือนการอัปเดตทรัพยากรช่วยให้สามารถสตรีมผลลัพธ์ระหว่างทางได้ แม้ว่าจะต้องมีการออกแบบอย่างรอบคอบเพื่อหลีกเลี่ยงความขัดแย้งกับโมเดลการร้องขอ/ตอบสนอง 1:1 ของ JSON-RPC

| คุณสมบัติ                | กรณีการใช้งาน                                                                                                                                                                       | การสนับสนุน MCP                                                                          |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| การอัปเดตความคืบหน้าแบบเรียลไทม์ | ผู้ใช้ร้องขอการย้ายโค้ดเบส เอเจนต์สตรีมความคืบหน้า: "10% - กำลังวิเคราะห์ dependencies... 25% - กำลังแปลงไฟล์ TypeScript... 50% - กำลังอัปเดต imports..."          | ✅ การแจ้งเตือนความคืบหน้า                                                              |
| ผลลัพธ์ระหว่างทาง         | งาน "สร้างหนังสือ" สตรีมผลลัพธ์ระหว่างทาง เช่น 1) โครงเรื่อง 2) รายการบท 3) แต่ละบทเมื่อเสร็จสิ้น โฮสต์สามารถตรวจสอบ ยกเลิก หรือเปลี่ยนเส้นทางในแต่ละขั้นตอน | ✅ การแจ้งเตือนสามารถ "ขยาย" เพื่อรวมผลลัพธ์ระหว่างทาง ดูข้อเสนอใน PR 383, 776         |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 1:</strong> แผนภาพนี้แสดงให้เห็นว่าเอเจนต์ MCP สตรีมการอัปเดตความคืบหน้าแบบเรียลไทม์และผลลัพธ์ระหว่างทางไปยังแอปพลิเคชันโฮสต์ระหว่างงานที่ใช้เวลานาน ทำให้ผู้ใช้สามารถติดตามการทำงานได้แบบเรียลไทม์
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)

    User->>Host: Start long task
    Host->>Server: Call agent_tool()

    loop Progress Updates
        Server-->>Host: Progress + partial results
        Host-->>User: Stream updates
    end

    Server-->>Host: ✅ Final result
    Host-->>User: Complete
```

### 2. Resumability

เอเจนต์ต้องจัดการกับการขัดจังหวะของเครือข่ายอย่างราบรื่น:

- เชื่อมต่อใหม่หลังจากการตัดการเชื่อมต่อ (client)
- ดำเนินการต่อจากจุดที่หยุดไว้ (message redelivery)

**การสนับสนุน MCP**: MCP StreamableHTTP transport ในปัจจุบันรองรับการกลับมาเชื่อมต่อเซสชันและการส่งข้อความซ้ำด้วย session IDs และ last event IDs สิ่งสำคัญคือเซิร์ฟเวอร์ต้องมีการใช้งาน EventStore ที่ช่วยให้สามารถเล่นเหตุการณ์ซ้ำได้เมื่อ client เชื่อมต่อใหม่  
มีข้อเสนอจากชุมชน (PR #975) ที่สำรวจการสตรีมที่สามารถกลับมาเชื่อมต่อได้โดยไม่ขึ้นกับ transport

| คุณสมบัติ      | กรณีการใช้งาน                                                                                                                                                   | การสนับสนุน MCP                                                        |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Resumability    | Client ตัดการเชื่อมต่อระหว่างงานที่ใช้เวลานาน เมื่อเชื่อมต่อใหม่ เซสชันจะกลับมาทำงานต่อพร้อมเหตุการณ์ที่พลาดไปถูกเล่นซ้ำ ทำให้ดำเนินการต่อได้อย่างราบรื่น | ✅ StreamableHTTP transport พร้อม session IDs, การเล่นเหตุการณ์ซ้ำ และ EventStore |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 2:</strong> แผนภาพนี้แสดงให้เห็นว่า StreamableHTTP transport และ event store ของ MCP ช่วยให้การกลับมาเชื่อมต่อเซสชันเป็นไปอย่างราบรื่น: หาก client ตัดการเชื่อมต่อ สามารถเชื่อมต่อใหม่และเล่นเหตุการณ์ที่พลาดไปได้ ทำให้งานดำเนินต่อไปโดยไม่สูญเสียความคืบหน้า
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)
    participant Store as Event Store

    User->>Host: Start task
    Host->>Server: Call tool [session: abc123]
    Server->>Store: Save events

    Note over Host,Server: 💥 Connection lost

    Host->>Server: Reconnect [session: abc123]
    Store-->>Server: Replay events
    Server-->>Host: Catch up + continue
    Host-->>User: ✅ Complete
```

### 3. Durability

เอเจนต์ที่ทำงานระยะยาวต้องการสถานะที่คงทน:

- ผลลัพธ์ยังคงอยู่แม้เซิร์ฟเวอร์จะรีสตาร์ท
- สถานะสามารถเรียกดูได้จากภายนอก
- การติดตามความคืบหน้าข้ามเซสชัน

**การสนับสนุน MCP**: MCP ปัจจุบันรองรับประเภทการคืนค่า Resource link สำหรับการเรียกใช้เครื่องมือ วันนี้ รูปแบบที่เป็นไปได้คือการออกแบบเครื่องมือที่สร้างทรัพยากรและคืนค่า resource link ทันที เครื่องมือสามารถดำเนินการจัดการงานในพื้นหลังและอัปเดตทรัพยากรได้ ในทางกลับกัน client สามารถเลือกที่จะดึงสถานะของทรัพยากรนี้เพื่อรับผลลัพธ์บางส่วนหรือทั้งหมด (ขึ้นอยู่กับการอัปเดตทรัพยากรที่เซิร์ฟเวอร์ให้) หรือสมัครรับการแจ้งเตือนการอัปเดตทรัพยากร

ข้อจำกัดหนึ่งในที่นี้คือการดึงทรัพยากรหรือสมัครรับการอัปเดตอาจใช้ทรัพยากรและมีผลกระทบในระดับใหญ่ มีข้อเสนอจากชุมชน (รวมถึง #992) ที่สำรวจความเป็นไปได้ในการรวม webhooks หรือ triggers ที่เซิร์ฟเวอร์สามารถเรียกเพื่อแจ้งให้ client/แอปพลิเคชันโฮสต์ทราบถึงการอัปเดต

| คุณสมบัติ    | กรณีการใช้งาน                                                                                                                                        | การสนับสนุน MCP                                                        |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Durability    | เซิร์ฟเวอร์ล่มระหว่างงานย้ายข้อมูล ผลลัพธ์และความคืบหน้ายังคงอยู่หลังการรีสตาร์ท client สามารถตรวจสอบสถานะและดำเนินการต่อจากทรัพยากรที่คงทนได้ | ✅ Resource links พร้อมการจัดเก็บข้อมูลที่คงทนและการแจ้งเตือนสถานะ |

วันนี้ รูปแบบทั่วไปคือการออกแบบเครื่องมือที่สร้างทรัพยากรและคืนค่า resource link ทันที เครื่องมือสามารถจัดการงานในพื้นหลัง ออกการแจ้งเตือนทรัพยากรที่ทำหน้าที่เป็นการอัปเดตความคืบหน้าหรือรวมผลลัพธ์บางส่วน และอัปเดตเนื้อหาในทรัพยากรตามความจำเป็น

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 3:</strong> แผนภาพนี้แสดงให้เห็นว่าเอเจนต์ MCP ใช้ทรัพยากรที่คงทนและการแจ้งเตือนสถานะเพื่อให้แน่ใจว่างานที่ใช้เวลานานสามารถอยู่รอดจากการรีสตาร์ทเซิร์ฟเวอร์ ทำให้ client สามารถตรวจสอบความคืบหน้าและดึงผลลัพธ์ได้แม้หลังจากเกิดความล้มเหลว
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)
    participant DB as Persistent Storage

    User->>Host: Start task
    Host->>Server: Call tool
    Server->>DB: Create resource + updates
    Server-->>Host: 🔗 Resource link

    Note over Server: 💥 Server restart

    User->>Host: Check status
    Host->>Server: Get resource
    Server->>DB: Load state
    Server-->>Host: Current progress
    Server->>DB: Complete + notify
    Host-->>User: ✅ Complete
```

### 4. Multi-Turn Interactions

เอเจนต์มักต้องการข้อมูลเพิ่มเติมระหว่างการทำงาน:

- การยืนยันหรือคำชี้แจงจากมนุษย์
- ความช่วยเหลือจาก AI สำหรับการตัดสินใจที่ซับซ้อน
- การปรับพารามิเตอร์แบบไดนามิก

**การสนับสนุน MCP**: รองรับอย่างเต็มที่ผ่าน sampling (สำหรับข้อมูลจาก AI) และ elicitation (สำหรับข้อมูลจากมนุษย์)

| คุณสมบัติ                 | กรณีการใช้งาน                                                                                                                                     | การสนับสนุน MCP                                           |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| Multi-Turn Interactions   | เอเจนต์จองการเดินทางร้องขอการยืนยันราคาจากผู้ใช้ จากนั้นขอให้ AI สรุปข้อมูลการเดินทางก่อนดำเนินการจองให้เสร็จสมบูรณ์                       | ✅ Elicitation สำหรับข้อมูลจากมนุษย์, sampling สำหรับข้อมูลจาก AI |

<div align="center" style="font-style: italic; font-size: 0.95em; margin-bottom: 0.5em;">
<strong>รูปที่ 4:</strong> แผนภาพนี้แสดงให้เห็นว่าเอเจนต์ MCP สามารถร้องขอข้อมูลจากมนุษย์หรือขอความช่วยเหลือจาก AI ระหว่างการทำงาน สนับสนุนเวิร์กโฟลว์ที่ซับซ้อนและมีหลายขั้นตอน เช่น การยืนยันและการตัดสินใจแบบไดนามิก
</div>

```mermaid
sequenceDiagram
    participant User
    participant Host as Host App<br/>(MCP Client)
    participant Server as MCP Server<br/>(Agent Tool)

    User->>Host: Book flight
    Host->>Server: Call travel_agent

    Server->>Host: Elicitation: "Confirm $500?"
    Note over Host: Elicitation callback (if available)
    Host->>User: 💰 Confirm price?
    User->>Host: "Yes"
    Host->>Server: Confirmed

    Server->>Host: Sampling: "Summarize data"
    Note over Host: AI callback (if available)
    Host->>Server: Report summary

    Server->>Host: ✅ Flight booked
```

## การใช้งานเอเจนต์ที่ทำงานระยะยาวบน MCP - ภาพรวมของโค้ด

ในบทความนี้ เราได้จัดเตรียม [คลังโค้ด](https://github.com/victordibia/ai-tutorials/tree/main/MCP%20Agents) ที่มีการใช้งานเอเจนต์ที่ทำงานระยะยาวอย่างสมบูรณ์โดยใช้ MCP Python SDK พร้อม StreamableHTTP transport สำหรับการกลับมาเชื่อมต่อเซสชันและการส่งข้อความซ้ำ การใช้งานนี้แสดงให้เห็นว่า MCP สามารถประกอบความสามารถต่างๆ เพื่อเปิดใช้งานพฤติกรรมแบบเอเจนต์ที่ซับซ้อนได้อย่างไร

... (เนื้อหาที่เหลือยังคงเหมือนเดิม) ...

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้อง แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่แม่นยำ เอกสารต้นฉบับในภาษาต้นทางควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ แนะนำให้ใช้บริการแปลภาษาจากผู้เชี่ยวชาญ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความที่ผิดพลาดซึ่งเกิดจากการใช้การแปลนี้