<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "d2c9703548140bafa2d6a77406552542",
  "translation_date": "2025-10-03T14:23:17+00:00",
  "source_file": "13-agent-memory/README.md",
  "language_code": "ko"
}
-->
# AI 에이전트의 메모리
[![Agent Memory](../../../translated_images/lesson-13-thumbnail.959e3bc52d210c64a614a3bece6b170a2c472138dc0a14c7fbde07306ef95ae7.ko.png)](https://youtu.be/QrYbHesIxpw?si=qNYW6PL3fb3lTPMk)

AI 에이전트를 만드는 데 있어 독특한 이점에 대해 논의할 때 주로 두 가지가 언급됩니다: 도구를 호출하여 작업을 완료하는 능력과 시간이 지남에 따라 개선되는 능력입니다. 메모리는 사용자에게 더 나은 경험을 제공할 수 있는 자기 개선 에이전트를 만드는 데 있어 핵심입니다.

이번 강의에서는 AI 에이전트의 메모리가 무엇인지, 이를 어떻게 관리하고 애플리케이션에 활용할 수 있는지 살펴보겠습니다.

## 소개

이번 강의에서는 다음 내용을 다룹니다:

• **AI 에이전트 메모리 이해하기**: 메모리가 무엇이며 에이전트에게 왜 중요한지.

• **메모리 구현 및 저장**: 단기 및 장기 메모리에 초점을 맞춘 AI 에이전트에 메모리 기능을 추가하는 실질적인 방법.

• **AI 에이전트를 자기 개선 가능하게 만들기**: 메모리가 과거 상호작용에서 학습하고 시간이 지남에 따라 개선할 수 있도록 하는 방법.

## 학습 목표

이 강의를 완료한 후, 여러분은 다음을 알게 될 것입니다:

• **AI 에이전트 메모리의 다양한 유형을 구분하기**: 작업 메모리, 단기 메모리, 장기 메모리, 그리고 페르소나 및 에피소드 메모리와 같은 특수 형태.

• **AI 에이전트의 단기 및 장기 메모리를 구현하고 관리하기**: Semantic Kernel 프레임워크를 활용하여 Mem0 및 Whiteboard 메모리와 같은 도구를 사용하고 Azure AI Search와 통합.

• **자기 개선 AI 에이전트의 원리를 이해하기**: 강력한 메모리 관리 시스템이 지속적인 학습과 적응에 어떻게 기여하는지.

## AI 에이전트 메모리 이해하기

기본적으로, **AI 에이전트의 메모리는 정보를 유지하고 회상할 수 있는 메커니즘을 의미합니다**. 이 정보는 대화의 특정 세부사항, 사용자 선호도, 과거 행동, 또는 학습된 패턴일 수 있습니다.

메모리가 없으면 AI 애플리케이션은 종종 상태를 유지하지 못하며, 각 상호작용이 처음부터 시작됩니다. 이는 에이전트가 이전의 맥락이나 선호도를 "잊어버리는" 반복적이고 답답한 사용자 경험을 초래합니다.

### 메모리가 왜 중요한가?

에이전트의 지능은 과거 정보를 회상하고 활용하는 능력과 깊이 연결되어 있습니다. 메모리는 에이전트를 다음과 같이 만듭니다:

• **반성적**: 과거 행동과 결과에서 학습.

• **상호작용적**: 진행 중인 대화의 맥락을 유지.

• **능동적 및 반응적**: 과거 데이터를 기반으로 필요를 예측하거나 적절히 대응.

• **자율적**: 저장된 지식을 활용하여 더 독립적으로 작동.

메모리를 구현하는 목표는 에이전트를 더 **신뢰할 수 있고 능력 있는** 존재로 만드는 것입니다.

### 메모리의 유형

#### 작업 메모리

작업 메모리는 에이전트가 단일 작업이나 사고 과정 중에 사용하는 임시 메모지와 같습니다. 다음 단계를 계산하는 데 필요한 즉각적인 정보를 보유합니다.

AI 에이전트의 경우, 작업 메모리는 대화에서 가장 관련성이 높은 정보를 캡처하며, 전체 채팅 기록이 길거나 잘려 있더라도 핵심 요소를 추출하는 데 집중합니다. 여기에는 요구사항, 제안, 결정, 행동 등이 포함됩니다.

**작업 메모리 예시**

여행 예약 에이전트에서 작업 메모리는 사용자의 현재 요청, 예를 들어 "파리로 여행을 예약하고 싶어요"와 같은 요구사항을 캡처하여 현재 상호작용을 안내합니다.

#### 단기 메모리

이 유형의 메모리는 단일 대화나 세션 동안 정보를 유지합니다. 현재 채팅의 맥락을 유지하여 에이전트가 대화의 이전 턴을 참조할 수 있도록 합니다.

**단기 메모리 예시**

사용자가 "파리로 가는 항공편 비용은 얼마인가요?"라고 묻고 이어서 "거기 숙박은 어떻죠?"라고 질문하면, 단기 메모리는 "거기"가 같은 대화 내에서 "파리"를 의미한다는 것을 에이전트가 알 수 있도록 합니다.

#### 장기 메모리

이 메모리는 여러 대화나 세션에 걸쳐 정보를 유지합니다. 에이전트가 사용자 선호도, 과거 상호작용, 또는 일반적인 지식을 장기간 기억할 수 있도록 합니다. 이는 개인화에 중요합니다.

**장기 메모리 예시**

장기 메모리는 "벤은 스키와 야외 활동을 좋아하고, 산 전망이 있는 커피를 선호하며, 과거 부상으로 인해 고급 스키 슬로프를 피하고 싶어한다"는 정보를 저장할 수 있습니다. 이전 상호작용에서 학습한 이 정보는 미래 여행 계획 세션에서 추천을 개인화하는 데 영향을 미칩니다.

#### 페르소나 메모리

이 특수한 메모리 유형은 에이전트가 일관된 "성격" 또는 "페르소나"를 개발하도록 돕습니다. 에이전트가 자신에 대한 세부사항이나 의도된 역할을 기억하여 상호작용을 더 유연하고 집중적으로 만듭니다.

**페르소나 메모리 예시**

여행 에이전트가 "스키 전문가"로 설계되었다면, 페르소나 메모리는 이 역할을 강화하여 전문가의 어조와 지식을 반영하는 응답을 제공하도록 영향을 미칩니다.

#### 워크플로우/에피소드 메모리

이 메모리는 에이전트가 복잡한 작업을 수행하는 동안의 단계 순서, 성공 및 실패를 저장합니다. 이는 특정 "에피소드" 또는 과거 경험을 기억하여 학습하는 것과 같습니다.

**에피소드 메모리 예시**

에이전트가 특정 항공편을 예약하려 했지만 이용 불가로 실패한 경우, 에피소드 메모리는 이 실패를 기록하여 대체 항공편을 시도하거나 이후 시도에서 사용자에게 문제를 더 잘 알릴 수 있도록 합니다.

#### 엔티티 메모리

이 메모리는 대화에서 사람, 장소, 사물과 같은 특정 엔티티와 이벤트를 추출하고 기억하는 것을 포함합니다. 에이전트가 논의된 주요 요소에 대한 구조화된 이해를 구축할 수 있도록 합니다.

**엔티티 메모리 예시**

과거 여행에 대한 대화에서 에이전트는 "파리", "에펠탑", "Le Chat Noir 레스토랑에서의 저녁 식사"와 같은 엔티티를 추출할 수 있습니다. 이후 상호작용에서 에이전트는 "Le Chat Noir"를 기억하고 새로운 예약을 제안할 수 있습니다.

#### 구조화된 RAG (Retrieval Augmented Generation)

RAG는 더 넓은 기술이지만, "구조화된 RAG"는 강력한 메모리 기술로 강조됩니다. 이는 대화, 이메일, 이미지와 같은 다양한 소스에서 밀도 높은 구조화된 정보를 추출하여 응답의 정확성, 회상력, 속도를 향상시킵니다. 고전적인 RAG가 의미적 유사성에만 의존하는 것과 달리, 구조화된 RAG는 정보의 고유한 구조를 활용합니다.

**구조화된 RAG 예시**

단순히 키워드를 매칭하는 대신, 구조화된 RAG는 이메일에서 항공편 세부사항(목적지, 날짜, 시간, 항공사)을 분석하여 구조화된 방식으로 저장할 수 있습니다. 이를 통해 "화요일에 파리로 예약한 항공편은 무엇인가요?"와 같은 정확한 쿼리를 처리할 수 있습니다.

## 메모리 구현 및 저장

AI 에이전트의 메모리를 구현하는 것은 **메모리 관리**의 체계적인 과정을 포함합니다. 여기에는 정보 생성, 저장, 검색, 통합, 업데이트, 그리고 "잊기"(또는 삭제)가 포함됩니다. 특히 검색은 중요한 측면입니다.

### 특수 메모리 도구

에이전트 메모리를 저장하고 관리하는 한 가지 방법은 Mem0와 같은 특수 도구를 사용하는 것입니다. Mem0는 지속적인 메모리 계층으로 작동하여 에이전트가 관련 상호작용을 회상하고, 사용자 선호도와 사실적 맥락을 저장하며, 시간에 따라 성공과 실패에서 학습할 수 있도록 합니다. 여기서 아이디어는 상태를 유지하지 않는 에이전트를 상태를 유지하는 에이전트로 바꾸는 것입니다.

Mem0는 **추출 및 업데이트의 두 단계 메모리 파이프라인**을 통해 작동합니다. 먼저, 에이전트의 스레드에 추가된 메시지가 Mem0 서비스로 전송되며, 이는 대화 기록을 요약하고 새로운 메모리를 추출하기 위해 대형 언어 모델(LLM)을 사용합니다. 이후, LLM 기반 업데이트 단계는 이러한 메모리를 추가, 수정 또는 삭제할지 여부를 결정하여 벡터, 그래프, 키-값 데이터베이스를 포함할 수 있는 하이브리드 데이터 저장소에 저장합니다. 이 시스템은 다양한 메모리 유형을 지원하며 엔티티 간 관계를 관리하기 위해 그래프 메모리를 통합할 수도 있습니다.

### RAG를 활용한 메모리 저장

Mem0와 같은 특수 메모리 도구 외에도, **Azure AI Search**와 같은 강력한 검색 서비스를 메모리 저장 및 검색의 백엔드로 활용할 수 있습니다. 특히 구조화된 RAG에 적합합니다.

이를 통해 에이전트의 응답을 자체 데이터로 기반화하여 더 관련성 있고 정확한 답변을 보장할 수 있습니다. Azure AI Search는 사용자별 여행 메모리, 제품 카탈로그, 또는 기타 도메인별 지식을 저장하는 데 사용할 수 있습니다.

Azure AI Search는 **구조화된 RAG**와 같은 기능을 지원하며, 이는 대화 기록, 이메일, 또는 이미지와 같은 대규모 데이터셋에서 밀도 높은 구조화된 정보를 추출하고 검색하는 데 뛰어납니다. 이는 기존 텍스트 청킹 및 임베딩 접근법에 비해 "초인적인 정확성과 회상력"을 제공합니다.

## AI 에이전트를 자기 개선 가능하게 만들기

자기 개선 에이전트를 위한 일반적인 패턴은 **"지식 에이전트"**를 도입하는 것입니다. 이 별도의 에이전트는 사용자와 주요 에이전트 간의 대화를 관찰합니다. 그 역할은 다음과 같습니다:

1. **유용한 정보 식별**: 대화의 일부가 일반 지식 또는 특정 사용자 선호도로 저장할 가치가 있는지 판단.

2. **추출 및 요약**: 대화에서 필수 학습 또는 선호도를 추출하여 요약.

3. **지식 베이스에 저장**: 추출된 정보를 벡터 데이터베이스에 저장하여 나중에 검색 가능하도록 유지.

4. **미래 쿼리 증강**: 사용자가 새로운 쿼리를 시작할 때, 지식 에이전트가 관련 저장 정보를 검색하여 사용자 프롬프트에 추가하여 주요 에이전트에 중요한 맥락을 제공 (RAG와 유사).

### 메모리 최적화

• **지연 시간 관리**: 사용자 상호작용 속도를 늦추지 않기 위해, 정보가 저장 또는 검색할 가치가 있는지 빠르게 확인하기 위해 저렴하고 빠른 모델을 처음에 사용하고, 필요할 때만 더 복잡한 추출/검색 프로세스를 호출.

• **지식 베이스 유지 관리**: 성장하는 지식 베이스의 경우, 덜 자주 사용되는 정보를 "콜드 스토리지"로 이동하여 비용을 관리.

## 에이전트 메모리에 대한 추가 질문이 있나요?

[Azure AI Foundry Discord](https://aka.ms/ai-agents/discord)에 참여하여 다른 학습자들과 만나고, 오피스 아워에 참석하며 AI 에이전트에 대한 질문을 해결하세요.

---

**면책 조항**:  
이 문서는 AI 번역 서비스 [Co-op Translator](https://github.com/Azure/co-op-translator)를 사용하여 번역되었습니다. 정확성을 위해 최선을 다하고 있으나, 자동 번역에는 오류나 부정확성이 포함될 수 있습니다. 원본 문서의 원어 버전이 권위 있는 출처로 간주되어야 합니다. 중요한 정보의 경우, 전문적인 인간 번역을 권장합니다. 이 번역 사용으로 인해 발생하는 오해나 잘못된 해석에 대해 당사는 책임을 지지 않습니다.